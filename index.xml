<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>semiosis</title>
    <link>http://semiosis.github.io/</link>
    <description>Recent content on semiosis</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
    <lastBuildDate>Wed, 15 Sep 2021 00:00:00 +1200</lastBuildDate><atom:link href="http://semiosis.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>An interpretation of the ideograms</title>
      <link>http://semiosis.github.io/posts/an-interpretation-of-the-ideograms/</link>
      <pubDate>Wed, 15 Sep 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/posts/an-interpretation-of-the-ideograms/</guid>
      <description>Summary Today I felt like I should try to interpret the ideograms that make up the semiosis logo.
 URL https://semiosis.github.io/  So I found my way to the linguistics section of the library and found a book.
  I realise that some of these symbols could be attributed in other ways but this the first interpretation I have attempted and an interesting one at that.
 The eclispe (end of a cycle / the world)   Cross of Loraine.</description>
    </item>
    
    <item>
      <title>Imaginary computing and virtual reality</title>
      <link>http://semiosis.github.io/posts/imaginary-computing/</link>
      <pubDate>Mon, 13 Sep 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/posts/imaginary-computing/</guid>
      <description>Summary I talk about the imaginary computing paradigm based on LMs.
Definitions  prompting The act of stoking a LM to perform a generation. imagination The extrapolation of a language model&amp;rsquo;s weights via prompting. The returned results of prompting.  Prompting pretrained LMs is a way to build imaginary analogs to most software. It is for this reason, that software may be defined within only the imagination of a LM. Therefore, we have a new computing paradigm that may not be called &amp;lsquo;virtual&amp;rsquo;.</description>
    </item>
    
    <item>
      <title>Your Imagination</title>
      <link>http://semiosis.github.io/posts/your-imagination/</link>
      <pubDate>Sun, 12 Sep 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/posts/your-imagination/</guid>
      <description>1 Kings 19:11-13 God’s Revelation to Elijah 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  11 Then He said, “Go out, and stand on the mountain before the Lord.” And behold, the Lord passed by, and a great and strong wind tore into the mountains and broke the rocks in pieces before the Lord, but the Lord was not in the wind; and after the wind an earthquake, but the Lord was not in the earthquake; 12 and after the earthquake a fire, but the Lord was not in the fire; and after the fire [a]a still small voice.</description>
    </item>
    
    <item>
      <title>The Eight Beatitudes</title>
      <link>http://semiosis.github.io/posts/the-eight-beatitudes/</link>
      <pubDate>Sat, 11 Sep 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/posts/the-eight-beatitudes/</guid>
      <description>Blessed are the poor in spirit, for theirs is the kingdom of heaven.   Be the last of all, the servant of all, do not judge others and share all. https://www.biblegateway.com/passage/?search=Matthew%205%3A3-12&amp;amp;version=NIV    Blessed are those who mourn, for they shall be comforted.   Consider well the people you and others have lost, the things you have not done well, and the things you long for.</description>
    </item>
    
    <item>
      <title>Browsing the imaginary web with Codex</title>
      <link>http://semiosis.github.io/posts/the-imaginary-web-with-codex/</link>
      <pubDate>Thu, 09 Sep 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/posts/the-imaginary-web-with-codex/</guid>
      <description>Summary I make an imaginary web browser. This will be improved in the future, but it&amp;rsquo;s already fairly trivial to browse the imaginary web. Let me show you how.
There is no need for the websites returned to be perfect as we have a tool Codex, which can make sense of the imperfect. This works fine as it is, just open your mind on the way in which people should view and interact with the web.</description>
    </item>
    
    <item>
      <title>Search the web with Codex (bye Google)</title>
      <link>http://semiosis.github.io/posts/search-the-web-with-codex/</link>
      <pubDate>Thu, 09 Sep 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/posts/search-the-web-with-codex/</guid>
      <description>Summary This is a demonstration of using a LM to search the internet.
This is a very effective search engine, actually. It pretty much replaces Google Search. The technology has tighter integration with tooling, faster look- up times, can be used offline etc. with (free models).
Demo  --  Select any text, code or prose or whatever, irrespective of if they have the keywords you would typically search for. Then it generates a bunch of URLs and you filter the results.</description>
    </item>
    
    <item>
      <title>Documentation for anything, anywhere, with Codex</title>
      <link>http://semiosis.github.io/posts/documentation-for-anything-anywhere-with-codex/</link>
      <pubDate>Wed, 08 Sep 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/posts/documentation-for-anything-anywhere-with-codex/</guid>
      <description>Summary This is just a quick demo showing that Codex can give you documentation for anything.
I&amp;rsquo;m actually demonstrating documentation inside the imaginary interpreters, right now.
Well there you go. Documentation for an imaginary library.
Demo  --  Documentation for an imaginary library   </description>
    </item>
    
    <item>
      <title>Imaginary Prolog interpreter with Codex</title>
      <link>http://semiosis.github.io/posts/imaginary-prolog-interpreter-with-codex/</link>
      <pubDate>Wed, 08 Sep 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/posts/imaginary-prolog-interpreter-with-codex/</guid>
      <description>Summary Imaginary Prolog interpreters with Codex are amazing.
Import imaginary databases, generate databases from queries.
 Previous GPT-3 experiment Comparing imaginary Prolog interpreters // Bodacious Blog  Demo Imaginary prolog databases  --  Generating databases from queries  -- </description>
    </item>
    
    <item>
      <title>Pen&#39;s nlsh for Codex - Stepping towards an imaginary OS</title>
      <link>http://semiosis.github.io/posts/pen-s-nlsh-for-codex/</link>
      <pubDate>Wed, 08 Sep 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/posts/pen-s-nlsh-for-codex/</guid>
      <description>Summary Codex is much more powerful, and so is Pen.el. This demo of nlsh gives me the chills.
Under the hood, Pen.el is coded using robust imaginary programming and lazy functions.
An imaginary operating system is being created where most functions are inferred.
It&amp;rsquo;s still very important to build tools to normalise imaginary code and languages onto the real axis.
Demo  --  Source A combination of lazy prompting with real emacs lisp, a dockerized Pen.</description>
    </item>
    
    <item>
      <title>Beyond the boundaries of paradigms</title>
      <link>http://semiosis.github.io/posts/beyond-the-boundaries-of-paradigms/</link>
      <pubDate>Tue, 07 Sep 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/posts/beyond-the-boundaries-of-paradigms/</guid>
      <description>Examples of ordinary programming paradigms  Type-Level programming  https://rebeccaskinner.net/posts/2021-08-25-introduction-to-type-level-programming.html   Relational Programming  https://github.com/webyrd/dissertation-single-spaced/blob/master/thesis.pdf   Functional programming Object-oriented programming Imperative programming  Questions to ponder  Where do ordinary programming paradigms end and what exists between and beyond them? Do there exist boundaries between physical, imaginary and metaphysical languages? What constitutes a new paradigm in programming? Arguably something that is orthogonal or unique to the rest. May Imaginary Programming (IP) be considered a new programming paradigm?</description>
    </item>
    
    <item>
      <title>Imaginary chimeric languages with Codex</title>
      <link>http://semiosis.github.io/posts/imaginary-chimera-languages-with-codex/</link>
      <pubDate>Tue, 07 Sep 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/posts/imaginary-chimera-languages-with-codex/</guid>
      <description>Summary I explore some imaginary chimeric languages with Codex.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  The Chimera Chimaera According to Greek mythology, was a monstrous fire-breathing hybrid creature of Lycia in Asia Minor, composed of the parts of more than one animal. It is usually depicted as a lion, with the head of a goat protruding from its back, and a tail that might end with a snake&amp;#39;s head.</description>
    </item>
    
    <item>
      <title>EmacsConf 2021 - Imaginary Programming</title>
      <link>http://semiosis.github.io/posts/emacsconf-2021-imaginary-programming/</link>
      <pubDate>Sun, 05 Sep 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/posts/emacsconf-2021-imaginary-programming/</guid>
      <description>Talk: Imaginary Programming Abstract: Imaginary Programming (IP) is both methodology and paradigm. It is an extension of literate programming and a way of creating software without the use of imperative, functional or even declarative code. Yet IP employs all disciplines to achieve the miraculous. The only contingency is on one or more language models, known as foundation models. The real value of IP is not found by abandoning sound logic altogether, but in weaving the real with the imaginary.</description>
    </item>
    
    <item>
      <title>iλ, a family of imaginary programming libraries</title>
      <link>http://semiosis.github.io/ilambda/</link>
      <pubDate>Fri, 03 Sep 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/ilambda/</guid>
      <description>iλ (Imaginary Programming Functions) Summary tl;dr: Imaginary Programming (IP) is where data and knowledge has been substituted for inference by a LM. Therefore, the implementation of an iλ library will be uniquely tailored to each language.
I design and build an IP library named iλ.el for emacs. Think of it a bit like a functional programming library in that you will find a set of functions and macros for working in the programming paradigm.</description>
    </item>
    
    <item>
      <title>iλ, an imaginary programming library for emacs</title>
      <link>http://semiosis.github.io/posts/ilambda/</link>
      <pubDate>Fri, 03 Sep 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/posts/ilambda/</guid>
      <description>iλ (Imaginary Programming Functions) Summary I design and build an imaginary programming (IP) library (iλ.el) for emacs. Think of it a bit like a functional programming library in that you will find a set of functions and macros for working in the programming paradigm. The objective here is to create some functions for doing IP in emacs lisp, since emacs lisp has the expressive power to prototype such things, but the ideas contained here can easily be transferred to any other programming language.</description>
    </item>
    
    <item>
      <title>A git commit message generator with Codex</title>
      <link>http://semiosis.github.io/posts/a-git-commit-message-generator-with-codex/</link>
      <pubDate>Thu, 02 Sep 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/posts/a-git-commit-message-generator-with-codex/</guid>
      <description>Summary I make a git commit message generator in Pen.el with OpenAI&amp;rsquo;s Codex.
Demo  --  Example diff  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  diff --git a/scripts/pen-ai21 b/scripts/pen-ai21 index 4859e4a..dbcbc7c 100755 --- a/scripts/pen-ai21 +++ b/scripts/pen-ai21 @@ -42,13 +42,15 @@ pen_ai21() { # cmd-nice-jq is very slow.</description>
    </item>
    
    <item>
      <title>Hiding personal information with OpenAI Codex</title>
      <link>http://semiosis.github.io/posts/hiding-personal-information-with-openai-codex/</link>
      <pubDate>Thu, 02 Sep 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/posts/hiding-personal-information-with-openai-codex/</guid>
      <description>Summary While creating a prompt for generating commit messages from diffs, I have made a personal information concealer.
Demo  --  Prompt  prompt http://github.com/semiosis/prompts/blob/master/prompts/randomize-private-info.prompt   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  task: &amp;#34;Hide personal information&amp;#34; doc: &amp;#34;Given a document with personal information, replace with random info instead&amp;#34; prompt-version: 1 prompt: |+# A file with sensitive information cat data.</description>
    </item>
    
    <item>
      <title>A syntax corrector with Codex</title>
      <link>http://semiosis.github.io/posts/a-syntax-corrector-with-codex/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/posts/a-syntax-corrector-with-codex/</guid>
      <description>Summary I just demonstrate the usage of a syntax corrector with Pen.el and codex. This is a lot like the spelling and grammar corrector prompt with GPT-3 Davinci.
Demo  --  Bad awk code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  if NR &amp;gt;= window_size &amp;amp;&amp;amp; (effective_nr % step == 0) { s = &amp;#34;&amp;#34; for (i=1; i&amp;lt;window_size; i++) { s = s memory[i] RS } s = s memory[window_size] printf(&amp;#34;(%s)&amp;#34;, s) |&amp;amp; cmd close(cmd, &amp;#34;to&amp;#34;); $0 = &amp;#34;&amp;#34; + &amp;#34;my string&amp;#34;; brs=RS RS=&amp;#34;##long read##&amp;#34; cmd |&amp;amp; getline $0; fflush(cmd); close(cmd); RS=brs print; system(&amp;#34;&amp;#34;); }   Corrected code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  if (NR &amp;gt;= window_size &amp;amp;&amp;amp; (effective_nr % step == 0)) { s = &amp;#34;&amp;#34; for (i=1; i&amp;lt;window_size; i++) { s = s memory[i] RS } s = s memory[window_size] printf(&amp;#34;(%s)&amp;#34;, s) |&amp;amp; cmd close(cmd, &amp;#34;to&amp;#34;); $0 = &amp;#34;&amp;#34; &amp;#34;my string&amp;#34;; brs=RS RS=&amp;#34;##long read##&amp;#34; cmd |&amp;amp; getline $0; fflush(cmd); close(cmd); RS=brs print; system(&amp;#34;&amp;#34;); }   Prompt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64  task: &amp;#34;Correct the syntax&amp;#34; doc: &amp;#34;Given some selected code, correct the syntax&amp;#34; prompt-version: 1 prompt: |+&amp;#34;&amp;#34;&amp;#34; The following awk has incorrect syntax: &amp;#34;&amp;#34;&amp;#34; if NR &amp;gt;= window_size &amp;amp;&amp;amp; (effective_nr % step == 0) { $0 = &amp;#34;&amp;#34; + &amp;#34;my string&amp;#34;; } &amp;#34;&amp;#34;&amp;#34; The same program but with corrected syntax: &amp;#34;&amp;#34;&amp;#34; if (NR &amp;gt;= window_size &amp;amp;&amp;amp; (effective_nr % step == 0)) { $0 = &amp;#34;&amp;#34; &amp;#34;my string&amp;#34;; } &amp;#34;&amp;#34;&amp;#34; The following &amp;lt;language&amp;gt; has incorrect syntax: &amp;#34;&amp;#34;&amp;#34; &amp;lt;bad code&amp;gt; &amp;#34;&amp;#34;&amp;#34; The same program but with corrected syntax: &amp;#34;&amp;#34;&amp;#34; engine: &amp;#34;OpenAI Codex&amp;#34; stop-sequences: - &amp;#34;\&amp;#34;\&amp;#34;\&amp;#34;&amp;#34; temperature: 0.</description>
    </item>
    
    <item>
      <title>An imaginary linter with Codex</title>
      <link>http://semiosis.github.io/posts/an-imaginary-linter-with-codex/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/posts/an-imaginary-linter-with-codex/</guid>
      <description>Summary I demonstrate an imaginary linter with Codex. This predicts an error message for a line of awk code. However, it also infers when the code is correct, so it&amp;rsquo;s useful.
The accuracy is not really good enough to make a reliable imaginary linter, but should work better with more popular languages such as Python.
In any case, I will build the tooling around prompts to perform linting.
Demo Correctly identifies syntax error 7 times out of 20  --  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  6: } 5: ^ syntax error 6: } 5: ^ syntax error 5: ^ syntax error 5: ^ 6: } 5: ^ syntax error 6: } 6: } 6: } 6: } 6: } 6: } 6: } 5: ^ syntax error 6: } 5: ^ syntax error 6: } 5: ^ syntax error   Correctly identifies correct code 19 times out of 20  --  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  6: } 6: } 6: } 6: } 6: } 6: } 6: } 6: } 6: } 6: } 6: } 6: } 6: } 6: } 6: } 6: } 6: } 6: } 6: } 5: ^ syntax error   Prompt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  task: &amp;#34;Imagine an awk linter&amp;#34; doc: &amp;#34;Given a line of awk code, check it for errors&amp;#34; issues: - This doesn&amp;#39;t work very well at all.</description>
    </item>
    
    <item>
      <title>Select function (with signature help) from NL using Codex</title>
      <link>http://semiosis.github.io/posts/select-function-with-signature-help-from-nl-using-codex/</link>
      <pubDate>Tue, 31 Aug 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/posts/select-function-with-signature-help-from-nl-using-codex/</guid>
      <description>Summary I create a handy function to suggest functions along with signature help, using Codex.
elisp 1 2 3 4 5 6 7  (defun pen-select-function-from-nl (use-case) (interactive (list (read-string &amp;#34;pen-select-function-from-nl use-case: &amp;#34;))) (let* ((lang ;; (pen-detect-language-ask) (read-string-hist &amp;#34;pen-select-function-from-nl lang: &amp;#34;)) (funs (pf-find-a-function-given-a-use-case/2 lang use-case :no-select-result t)) (sigs (pf-get-the-signatures-for-a-list-of-functions/2 lang (list2str funs) :no-select-result t))) (xc (fz (-zip-lists funs sigs) nil nil &amp;#34;pen-select-function-from-nl: &amp;#34;))))   Demos Concurrency with ipython and codex  --  Bash process management 1 2 3 4 5 6 7 8 9 10 11 12  kill # kill PID ps # ps -ef wait # wait $PID exec # exec $SHELL trap # trap &amp;#39;commands&amp;#39; SIGINT bg # bg %1 fg # fg %1 disown # disown %1 jobs # jobs killall # killall command killall5 # killall5 -9 command pkill # pkill -9 command   Haskell process management 1 2 3 4 5 6 7 8  forkIO # forkIO :: IO () kill # kill :: ProcessId -&amp;gt; IO () killProcess # killProcess :: ProcessId -&amp;gt; IO () killThread # killThread :: ThreadId -&amp;gt; IO () nice # nice :: Int -&amp;gt; IO () openProcess # openProcess :: ProcessId -&amp;gt; IO () openProcessIO # openProcessIO :: ProcessId -&amp;gt; IO (ProcessIO) openProcessPID # openProcessPID :: ProcessId -&amp;gt; IO (ProcessId)   While in the interpreter:</description>
    </item>
    
    <item>
      <title>Prompts to search for functions in Pen.el</title>
      <link>http://semiosis.github.io/posts/prompts-to-search-for-functions-in-pen-el/</link>
      <pubDate>Mon, 30 Aug 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/posts/prompts-to-search-for-functions-in-pen-el/</guid>
      <description>Summary Here are some prompts for generating functions and signatures from NL. What functions do you need? What are their signatures?
Demo  --  Prompts  use case http://github.com/semiosis/prompts/blob/master/prompts/find-a-function-given-a-use-case-2.prompt signature http://github.com/semiosis/prompts/blob/master/prompts/get-the-signatures-for-a-list-of-functions-2.prompt  find-a-function-given-a-use-case-2.prompt
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  task: &amp;#34;Find a function given a use-case&amp;#34; doc: &amp;#34;Given a language and a use-case, find a function for that use-case&amp;#34; prompt-version: 1 prompt: |+This is a list of the names of standard functions for &amp;lt;use case&amp;gt; in &amp;lt;language&amp;gt;: - engine: &amp;#34;OpenAI Codex&amp;#34; temperature: 0.</description>
    </item>
    
    <item>
      <title>Transforming prose and code, in a generic way</title>
      <link>http://semiosis.github.io/posts/transforming-prose-and-code-in-a-generic-way/</link>
      <pubDate>Sun, 29 Aug 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/posts/transforming-prose-and-code-in-a-generic-way/</guid>
      <description>Summary I demonstrate two prompts I have made. The first is based on OpenAI&amp;rsquo;s Davinci and I use it to transform prose. The other is based on OpenAI&amp;rsquo;s Davinci-Codex and I use it to transform code.
The prompts are parameterised to accept a NL description of a transformation to make. Rather than creating individual prompts for specific transformations or types of transformations, I simply have 2 generic transformation prompts.
Davinci appears to be more adept at transforming prose due to not to have had any fine-tuning which distracts it from its world- language oriented tasks.</description>
    </item>
    
    <item>
      <title>An emacs Imaginary Interpreter with history, completion and evaluation</title>
      <link>http://semiosis.github.io/posts/an-emacs-imaginary-interpreter-with-history-completion-and-evaluation/</link>
      <pubDate>Wed, 25 Aug 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/posts/an-emacs-imaginary-interpreter-with-history-completion-and-evaluation/</guid>
      <description>Summary This is a demonstration of an imaginary interpreter in emacs along with multiple modes of forward completion (word, 5 words, line, longform), imaginary memory, a real history and an imaginary tutor.
Demo  --  Utilising many different prompt functions to provide an imaginary python interpreter &amp;ndash; All in GPT-3. This is not even codex! Just imagine what could be done with Pen.el and codex!</description>
    </item>
    
    <item>
      <title>Codex for anything: Imaginary &#43; Real (with a bit of Codex) = Complex</title>
      <link>http://semiosis.github.io/posts/imaginary-real-codex-complex/</link>
      <pubDate>Wed, 25 Aug 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/posts/imaginary-real-codex-complex/</guid>
      <description>Summary tltr; I add an imaginary dimension to the emacs terminal using OpenAI-Codex.
Integrating real interpreters with imaginary ones creates something new that is greater than the sum of their parts; A complex terminal.
The complex terminal utilises the Codex LM to perform its underlying prompt functions. A complex terminal uses imaginary functions to enable the user to see what may happen upon running a command, to see what may follow after writing some code, and see what people usually do within a terminal context, no matter how deeply nested within interpreters or files.</description>
    </item>
    
    <item>
      <title>AI21, AIx, OpenAI and HuggingFace with Pen.el</title>
      <link>http://semiosis.github.io/ai21-aix-openai-and-huggingface-with-pen-el/</link>
      <pubDate>Mon, 23 Aug 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/ai21-aix-openai-and-huggingface-with-pen-el/</guid>
      <description>Summary I benchmark using several different LM engines in Pen.el.
Benchmark 100 tokens AI21 vs AIx vs OpenAI
AI21&amp;rsquo;s service is about as fast as OpenAI&amp;rsquo;s at about 6 seconds for 100 tokens, but AIx is significantly slower.
You may speed up AIx&amp;rsquo;s generations by subscribing to the GPU plan.
AI21 1 2 3 4 5  title: j1-jumbo include: Generic completion 50 tokens/1 prompt-version: 1 engine: AI21 J1-Jumbo max-tokens: 100   1 2 3 4 5 6 7  engine-title: AI21 J1-Jumbo lm-command: &amp;#34;ai21-complete.</description>
    </item>
    
    <item>
      <title>AI21, AIx, OpenAI and HuggingFace with Pen.el</title>
      <link>http://semiosis.github.io/posts/ai21-aix-openai-and-huggingface-with-pen-el/</link>
      <pubDate>Mon, 23 Aug 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/posts/ai21-aix-openai-and-huggingface-with-pen-el/</guid>
      <description>Summary I benchmark using several different LM engines in Pen.el.
Benchmark 100 tokens AI21 vs AIx vs OpenAI
AI21&amp;rsquo;s service is about as fast as OpenAI&amp;rsquo;s at about 6 seconds for 100 tokens, but AIx is significantly slower.
You may speed up AIx&amp;rsquo;s generations by subscribing to the GPU plan.
AI21 1 2 3 4 5  title: j1-jumbo include: Generic completion 50 tokens/1 prompt-version: 1 engine: AI21 J1-Jumbo max-tokens: 100   1 2 3 4 5 6 7  engine-title: AI21 J1-Jumbo lm-command: &amp;#34;ai21-complete.</description>
    </item>
    
    <item>
      <title>Comparing imaginary Prolog interpreters</title>
      <link>http://semiosis.github.io/posts/comparing-imaginary-prolog-interpreters/</link>
      <pubDate>Mon, 23 Aug 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/posts/comparing-imaginary-prolog-interpreters/</guid>
      <description>Summary I compare 3 different imaginary interpreters for Prolog with the GPT-3 language model.
The winner definitely goes to gprolog as the most reliable of the prolog imaginary interpreters.
Imaginary gprolog in GPT-3  Prompt http://github.com/semiosis/prompts/blob/master/prompts/imagine-a-prolog-db-interpreter-2.prompt  --  The imagined gprolog interpreter, in this instance, performed quite well. It was fairly accurate in querying this make-believe database.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  include: Generic Interpreter/3 task: Imagine a &amp;lt;language&amp;gt; interpreter language: prolog subprompts: - kickstarter: |+Welcome to SWI-Prolog (threaded, 64 bits, version 8.</description>
    </item>
    
    <item>
      <title>ii (Imaginary Interpreter)</title>
      <link>http://semiosis.github.io/an-exposition-of-pen-el-s-imaginary-interpreter/</link>
      <pubDate>Sun, 22 Aug 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/an-exposition-of-pen-el-s-imaginary-interpreter/</guid>
      <description>Summary This is an introduction to the imaginary interpreter built into Pen.el.
The reason I am building REPLs and emacs modes based around imaginary interpreters (which are not at all deterministic or logically sound) is that I believe they will be very powerful and useful in the future.
It&amp;rsquo;s important to develop a language-agnostic harness for working with arbitrarily many imagined languages.
Solving the problems of utilising current LMs will make it easier down the line to utilise more advanced ones.</description>
    </item>
    
    <item>
      <title>ii (Imaginary Interpreter)</title>
      <link>http://semiosis.github.io/ii/</link>
      <pubDate>Sun, 22 Aug 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/ii/</guid>
      <description>Summary This is an introduction to the imaginary interpreter built into Pen.el.
The reason I am building REPLs and emacs modes based around imaginary interpreters (which are not at all deterministic or logically sound) is that I believe they will be very powerful and useful in the future.
It&amp;rsquo;s important to develop a language-agnostic harness for working with arbitrarily many imagined languages.
Solving the problems of utilising current LMs will make it easier down the line to utilise more advanced ones.</description>
    </item>
    
    <item>
      <title>Translating prompts (i.e. NLP tasks) with GPT-3 and Pen.el</title>
      <link>http://semiosis.github.io/posts/translating-prompts-i-e-nlp-tasks-with-gpt-3-and-pen-el/</link>
      <pubDate>Thu, 19 Aug 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/posts/translating-prompts-i-e-nlp-tasks-with-gpt-3-and-pen-el/</guid>
      <description>Summary I demonstrate how to encode into your prompts information on how to translate it, so that it then becomes a straight-forward process to translate prompts/NLP tasks designed in different languages and sub-languages (topics) into your own language. This is important for people to be able to collaborate on prompts.
Translator example The translator takes stdin and templates into the command two arguments, from-language and to-language. The output is the prompt designed for a different language.</description>
    </item>
    
    <item>
      <title>Generating perl one-liners using GPT-3 and Pen.el</title>
      <link>http://semiosis.github.io/posts/generating-perl-one-liners-using-gpt-3-and-pen-el/</link>
      <pubDate>Wed, 18 Aug 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/posts/generating-perl-one-liners-using-gpt-3-and-pen-el/</guid>
      <description>Summary I demonstrate generating perl one-liners in emacs using a prompt function and explain parts of the prompt.
&amp;lt;:pp&amp;gt;perl - This enables you to specify the first part of the output. &amp;lt;:pp&amp;gt; is a placed where you want to include the rest of the prompt in the beginning of the output.
split-patterns  README http://github.com/semiosis/prompts/  split-patterns is a field for describing patterns to separate multiple prompt results from one output if the LM multiplexed the results intentionally or unintentionally.</description>
    </item>
    
    <item>
      <title>Ink.el (Intermediate Knowledge in emacs)</title>
      <link>http://semiosis.github.io/ink/</link>
      <pubDate>Mon, 16 Aug 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/ink/</guid>
      <description>Pen.el https://github.com/semiosis/pen.el Ink.el https://github.com/semiosis/ink.el prompts https://github.com/semiosis/prompts engines https://github.com/semiosis/engines Moire&amp;rsquo;s blog on Quantifying Curation https://generative.ink/posts/quantifying-curation/  Introducing Ink.el   The purpose of Ink.el is to encode within its text properties information about its own provenance. What was the intended meaning behind parts of the text? Annotations made by the writer are encoded in Ink. Where did the text originate? Data of a LM&amp;rsquo;s influence is also included.
It was created for Pen.</description>
    </item>
    
    <item>
      <title>Prompt design with YASnippet</title>
      <link>http://semiosis.github.io/posts/prompt-design-with-yasnippet/</link>
      <pubDate>Thu, 12 Aug 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/posts/prompt-design-with-yasnippet/</guid>
      <description>Summary I demonstrate the construction of an interactive prompt function in Pen.el from an initial prompt.
 Prompts http://github.com/semiosis/prompts  Demo  --  Explanation In the demo, a .prompt file was created from the selection of a raw prompt.
Towards the end, it was seen that some starting whitespace was preserved. This is because the prompt thought that it was an insertion.
Prompt functions may be given various modes. Insertion is used to prefer the insertion of the result of the generation to a document over other modes.</description>
    </item>
    
    <item>
      <title>The Codex Quine</title>
      <link>http://semiosis.github.io/posts/the-codex-quine/</link>
      <pubDate>Thu, 12 Aug 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/posts/the-codex-quine/</guid>
      <description>OpenAI Demo Converting Python to Ruby with OpenAI Codex - YouTube Pen.el Engine http://github.com/semiosis/engines/blob/master/engines/openai-codex.engine Pen.el Prompt http://github.com/semiosis/prompts/blob/master/prompts/transpile-3.prompt  Summary I convert the OpenAI quine relay into some imaginary code (WIP).
  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  ouroboros uroboros An ancient symbol depicting a serpent or dragon eating its own tail.</description>
    </item>
    
    <item>
      <title>GUI Spacemacs support for Dockerized Pen.el</title>
      <link>http://semiosis.github.io/posts/gui-spacemacs-support-for-dockerized-pen-el/</link>
      <pubDate>Wed, 11 Aug 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/posts/gui-spacemacs-support-for-dockerized-pen-el/</guid>
      <description>Summary I add support for Spacemacs in the Pen.el docker image.
         Pen.el on GitHub https://github.com/semiosis/pen.el/   Prompts on GitHub http://github.com/semiosis/prompts/   Tutorial https://semiosis.github.io/posts/pen-tutorial/   Discord channel invite https://discord.gg/JwKGbAdNHR    Demo This is me doing some code-generation in Spacemacs.
  And below is having inserted the code.
  And below, running in Google Chrome.
  </description>
    </item>
    
    <item>
      <title>GUI support for Pen.el Docker</title>
      <link>http://semiosis.github.io/posts/gui-support-for-pen-el-docker/</link>
      <pubDate>Tue, 10 Aug 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/posts/gui-support-for-pen-el-docker/</guid>
      <description>Summary I add GUI support for the Pen.el Docker image. Copy and paste works to and from the host.
  This functionality is enabled by default.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  case &amp;#34;$docker_cmd&amp;#34; in run) { IFS= read -r -d &amp;#39;&amp;#39; shcode &amp;lt;&amp;lt;HEREDOC # --user &amp;#34;$(id -u):$(id -g)&amp;#34; docker &amp;#34;$docker_cmd&amp;#34; \ $(test -n &amp;#34;$OPENAI_API_KEY&amp;#34; &amp;amp;&amp;amp; printf -- &amp;#34;%s &amp;#34; -e &amp;#34;OPENAI_API_KEY:$OPENAI_API_KEY&amp;#34; ) \ $(test -n &amp;#34;$PEN_CONFIG_DIR&amp;#34; &amp;amp;&amp;amp; printf -- &amp;#34;%s &amp;#34; -v &amp;#34;$PEN_CONFIG_DIR:/root/.</description>
    </item>
    
    <item>
      <title>Language agnostic code generator in Pen.el</title>
      <link>http://semiosis.github.io/posts/language-agnostic-code-generator-in-pen-el/</link>
      <pubDate>Tue, 10 Aug 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/posts/language-agnostic-code-generator-in-pen-el/</guid>
      <description>Summary Following on from YASnippet combined with Pen.el - Controllable prompt generation // Bodacious Blog, I make another language-agnostic code generator.
Behind the scenes, this prompt generates the comments describing a code snippet. The comments are in the desired language and the comments are removed from the results.
Prompt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  title: code generator from description doc: Language agnostic prompt-version: 1 lm-command: &amp;#34;openai-complete.</description>
    </item>
    
    <item>
      <title>Using Pen.el on the CLI to generate code snippets</title>
      <link>http://semiosis.github.io/posts/using-pen-el-on-the-cli-to-generate-code-snippets/</link>
      <pubDate>Tue, 10 Aug 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/posts/using-pen-el-on-the-cli-to-generate-code-snippets/</guid>
      <description>Summary I wanted to demo some of the code gen commands using the cli interface with org-babel.
Demos 1  penf -u pf-python-how-to &amp;#34;split a string&amp;#34;   s = &amp;#34;hello world&amp;#34; print s.split() # [&amp;#39;hello&amp;#39;, &amp;#39;world&amp;#39;] 1  pena -u code-question bash &amp;#34;save an array into a variable&amp;#34;   declare -a arr=([1]=1 [2]=2 [3]=3 [4]=4) declare -a arr=(1 2 3 4 5) declare -a array=(a b c d e f g) save_array=(${!</description>
    </item>
    
    <item>
      <title>YASnippet combined with Pen.el - Controllable prompt generation</title>
      <link>http://semiosis.github.io/posts/yasnippet-combined-with-pen-el-controllable-prompt-generation/</link>
      <pubDate>Mon, 09 Aug 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/posts/yasnippet-combined-with-pen-el-controllable-prompt-generation/</guid>
      <description>Summary I include YASnippet in the prompt generation pipeline to enable programmatic manipulation within a prompt using emacs functions and keyboard macros.
In essence, this gives you the ability to make language agnostic prompts.
This is using GPT-J by EleutherAI, via the AIx API.
Demo  --  The following is the prompting output. The comment was dynamically generated by YASnippet and the LM generated the line after the comment, which contained a valid regex.</description>
    </item>
    
    <item>
      <title>Porting the glossary system to Pen.el</title>
      <link>http://semiosis.github.io/posts/porting-the-glossary-system-to-pen-el/</link>
      <pubDate>Sat, 07 Aug 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/posts/porting-the-glossary-system-to-pen-el/</guid>
      <description>Summary I begin the porting of the glossary system to Pen.el. I feel like it&amp;rsquo;s an important learning tool to be able to construct glossaries while working with LMs.
The glossary is also important for helping the user to create context that enable prompt functions to be more precise.
Once a user develops their glossary to a degree, Pen.el will be able to recognise the context for which you are working within and be more accurate with its queries.</description>
    </item>
    
    <item>
      <title>Demo of GPT-J with Pen.el</title>
      <link>http://semiosis.github.io/posts/demo-of-gpt-j-with-pen-el/</link>
      <pubDate>Fri, 06 Aug 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/posts/demo-of-gpt-j-with-pen-el/</guid>
      <description>Summary I give a demo of GPT-J in Pen.el.
1 2 3 4  Datomic NLG: A database that is built on top of a distributed graph of data and relationships.   Translating languages 1 2 3  distributed graph NLG: A graph that is constructed using a number of different sized nodes and links.   1 2 3  arbre distribué NLG: Un graphe construit avec une grandeur différente de nœuds et de liaisons.</description>
    </item>
    
    <item>
      <title>Feedback from testing AIx GPT-J API in Pen.el</title>
      <link>http://semiosis.github.io/posts/feedback-from-testing-aix-gpt-j-api-in-pen-el/</link>
      <pubDate>Fri, 06 Aug 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/posts/feedback-from-testing-aix-gpt-j-api-in-pen-el/</guid>
      <description>Feedback Max tokens not working? I adjust the pen-aix script to print the tokens at the end of the completion.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  #!/usr/bin/python3 from aixapi import AIxResource import os # Get your API Key at apps.aixsolutionsgroup.com # model=os.environ.get(&amp;#34;PEN_ENGINE&amp;#34;), if __name__ == &amp;#34;__main__&amp;#34;: api_key = os.environ.get(&amp;#34;AIX_API_KEY&amp;#34;) aix_resource = AIxResource(api_key) print( str( aix_resource.</description>
    </item>
    
    <item>
      <title>vim dvorak colemak in insert mode</title>
      <link>http://semiosis.github.io/posts/vim-dvorak-colemak-in-insert-mode/</link>
      <pubDate>Fri, 06 Aug 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/posts/vim-dvorak-colemak-in-insert-mode/</guid>
      <description>Summary I demonstrate typing with dvorak / colemak while in insert mode, but retaining vim&amp;rsquo;s normal key bindings.
It&amp;rsquo;s better to do it this way then replacing your keyboard because the dvorak / colemak is only in insert-mode.
To switch bindings, use :K.
Code vimrc
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  set keymap=dvorakfunction!</description>
    </item>
    
    <item>
      <title>Having fun with Pen.el</title>
      <link>http://semiosis.github.io/posts/having-fun-with-pen-el/</link>
      <pubDate>Thu, 05 Aug 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/posts/having-fun-with-pen-el/</guid>
      <description>Translating from Disney into English  Uses bash, which connects to the Pen.el server. Uses the world translation prompt   --  Rugby pick up lines  --   Good ones:  I&amp;rsquo;m a total scrumptious hunk of man meat. I like your tackles. I&amp;rsquo;m just trying to tackle your heart. I think you would be a good scrum half. You can tackle me anytime.    Tomato pick up lines 1 2 3  #+BEGIN_SRC text -n :async :results verbatim code :f &amp;#34;pena pf-very-witty-pick-up-lines-for-a-topic&amp;#34; tomato #+END_SRC   Are you a slice of juicy sweetness?</description>
    </item>
    
    <item>
      <title>Pen.el the first IDE for both EleutherAI and OpenAI</title>
      <link>http://semiosis.github.io/posts/pen-el-the-first-ide-for-eleutherai-and-openai/</link>
      <pubDate>Tue, 03 Aug 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/posts/pen-el-the-first-ide-for-eleutherai-and-openai/</guid>
      <description>Summary I add support for EleutherAI&amp;rsquo;s GPT-j model via https://apps.aixsolutionsgroup.com/.
Get yourself a key from the link above if you&amp;rsquo;d like to try it out.
To try this out, firstly follow the setup instructions here:
 https://mullikine.github.io/posts/pen-tutorial/  To update / remove the keys at any time, use the following key bindings.
   kb f      M-o pen-add-key-openai pen-acolyte-minor-mode-map   M-a pen-add-key-aix pen-acolyte-minor-mode-map    If you remove one of the keys then Pen will attempt to use the other engine.</description>
    </item>
    
    <item>
      <title>Templating for prompt description files in Pen.el</title>
      <link>http://semiosis.github.io/posts/improved-templating-for-prompt-description-files-in-pen-el/</link>
      <pubDate>Tue, 03 Aug 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/posts/improved-templating-for-prompt-description-files-in-pen-el/</guid>
      <description>Summary I improve the templating system in .prompt files.
include key 1 2 3 4 5  title: ada include: Generic completion 50 tokens prompt-version: 1 lm-command: &amp;#34;openai-complete.sh&amp;#34; engine: ada   The above .prompt file will inherit the below keys, but may override some values.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  title: Generic completion 50 tokens prompt-version: 3 doc: This is a generic completer.</description>
    </item>
    
    <item>
      <title>Arbitrary keyword extraction with GPT-3, Pen.el and emacs</title>
      <link>http://semiosis.github.io/posts/arbitrary-keyword-extraction-with-gpt-3-pen-el-and-emacs/</link>
      <pubDate>Sun, 01 Aug 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/posts/arbitrary-keyword-extraction-with-gpt-3-pen-el-and-emacs/</guid>
      <description>Summary Using a mixture of emacs lisp, sed and prompts, I have made a reliable keyword extractor for emacs.
This is useful to be fed into other prompt functions, say for defining a word with the context which is given by the keyword extractor.
Prompt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  title: keyword extraction prompt-version: 6 prompt: |+Text and keywords: Text: Ethereum is a blockchain Keywords: blockchain, smart contracts, Turing-complete, distributed ledger ### Text and keywords: Text: &amp;lt;1&amp;gt; Keywords: engine: davinci n-collate: 1 n-completions: 3 temperature: 0.</description>
    </item>
    
    <item>
      <title>How to use Pen.el to autocomplete your code</title>
      <link>http://semiosis.github.io/posts/how-to-use-pen-el-to-autocomplete-your-code/</link>
      <pubDate>Sat, 31 Jul 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/posts/how-to-use-pen-el-to-autocomplete-your-code/</guid>
      <description>Summary I will just do some demonstrations on actually using Pen.el from within emacs.
 Project code https://github.com/semiosis/pen.el/  Config Pen map and Acolyte-mode map 1 2 3 4 5 6 7  (define-key pen-map (kbd &amp;#34;M-1&amp;#34;) #&amp;#39;pen-company-filetype-word) (define-key pen-map (kbd &amp;#34;M-2&amp;#34;) #&amp;#39;pen-company-filetype-words) (define-key pen-map (kbd &amp;#34;M-3&amp;#34;) #&amp;#39;pen-company-filetype-line) ;; company-mode long (define-key pen-map (kbd &amp;#34;M-4&amp;#34;) #&amp;#39;pen-company-filetype-long) ;; This uses ivy instead of company to present multiple lines (define-key pen-acolyte-minor-mode-map (kbd &amp;#34;M-l&amp;#34;) &amp;#39;pen-complete-long)   Pen autocompletion modes Word 1 2 3 4 5 6 7 8 9  (defmacro pen-word-complete (&amp;amp;rest body) &amp;#34;This wraps around pen function calls to make them complete long&amp;#34; `(eval `(let ((max-tokens 1) (stop-sequence &amp;#34;##long complete##&amp;#34;) (stop-sequences &amp;#39;(&amp;#34;##long complete##&amp;#34;)) (n-collate 1) (n-completions 40)) ,&amp;#39;,@body)))    --  Words 1 2 3 4 5 6 7 8 9  (defmacro pen-words-complete (&amp;amp;rest body) &amp;#34;This wraps around pen function calls to make them complete long&amp;#34; `(eval `(let ((max-tokens 5) (stop-sequence &amp;#34;##long complete##&amp;#34;) (stop-sequences &amp;#39;(&amp;#34;##long complete##&amp;#34;)) (n-collate 1) (n-completions 20)) ,&amp;#39;,@body)))    --  Line 1 2 3 4 5 6 7  (defmacro pen-line-complete (&amp;amp;rest body) &amp;#34;This wraps around pen function calls to make them complete line only&amp;#34; `(eval `(let ((max-tokens 100) (stop-sequence &amp;#34;\n&amp;#34;) (stop-sequences &amp;#39;(&amp;#34;\n&amp;#34;))) ,&amp;#39;,@body)))    --  Long 1 2 3 4 5 6 7  (defmacro pen-long-complete (&amp;amp;rest body) &amp;#34;This wraps around pen function calls to make them complete long&amp;#34; `(eval `(let ((max-tokens 200) (stop-sequence &amp;#34;##long complete##&amp;#34;) (stop-sequences &amp;#39;(&amp;#34;##long complete##&amp;#34;))) ,&amp;#39;,@body)))    -- </description>
    </item>
    
    <item>
      <title>Pen.el host interop and client/server</title>
      <link>http://semiosis.github.io/posts/pen-el-host-interop-and-client-server/</link>
      <pubDate>Thu, 29 Jul 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/posts/pen-el-host-interop-and-client-server/</guid>
      <description>Summary Pen.el may now run as a server. On your host OS, you can create symlinks to the pen script with names matching the name of prompts. Running those symlinks will then run the prompt via the server and return the result.
Alternatively, you can run pen pf-my-prompt-function &amp;quot;first arg&amp;quot; &amp;quot;second arg&amp;quot; &amp;quot;etc.&amp;quot; on the host machine and it will run the prompt function on the server and return the output as stdout on the host.</description>
    </item>
    
    <item>
      <title>Prompt chaining: Linking prompts together usefully in emacs</title>
      <link>http://semiosis.github.io/posts/using-emacs-prompt-functions-inside-other-prompt-functions/</link>
      <pubDate>Tue, 20 Jul 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/posts/using-emacs-prompt-functions-inside-other-prompt-functions/</guid>
      <description>Summary I demonstrate chaining together prompt functions.
You can define inside a .prompt to use a different prompt function For example, in this case, one prompt detects the language. The language is then sent as the first argument to the next prompt.
So basically the world languages prompt usually takes 2 arguments, FROM and TO, but FROM is automatically detected by the pf-get-language prompt function.
Demo  --  Prompts get-language.</description>
    </item>
    
    <item>
      <title>davinci-instruct-beta in emacs and Pen.el</title>
      <link>http://semiosis.github.io/davinci-instruct-beta-in-emacs-and-pen-el/</link>
      <pubDate>Sun, 18 Jul 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/davinci-instruct-beta-in-emacs-and-pen-el/</guid>
      <description>Summary I demonstrate the default behaviours of a .prompt engineered in Pen.el to do generation and insertion.
davinci-instruct-beta is a fine-tuned variant of GPT-3 designed to generate text given an NLP task.
Prompt A generic generation task.
http://github.com/semiosis/prompts/blob/master/prompts/generic-completion-50-tokens.prompt
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  in-development: no title: &amp;#34;generation task&amp;#34; prompt-version: 1 prompt: |+ &amp;lt;1&amp;gt; lm-command: &amp;#34;openai-complete.</description>
    </item>
    
    <item>
      <title>Imagery for Pen.el with CLIP and inspired from Myst: The Book of Atrus</title>
      <link>http://semiosis.github.io/posts/creating-some-imagery-for-pen-el-with-clip/</link>
      <pubDate>Thu, 15 Jul 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/posts/creating-some-imagery-for-pen-el-with-clip/</guid>
      <description>Original source material https://generative.ink/posts/alchemical-marriage-gpt-3-x-clip/#you-spin-worlds-together-and-untwine-them  Summary I follow the same instructions as in the aforementioned article to generate some imagery for Pen.el.
 Project code https://github.com/semiosis/pen.el/ Tutorial and exhibition https://mullikine.github.io/posts/pen-tutorial/ Join discord https://discord.gg/HH6PY27d  Thoughts Using Pen to generate a programming environment using a LM. NL is the easiest to use code for transforming images, programming languages and NLs. That&amp;rsquo;s why Pen exists, to be a shell for creativity, provenance and intelligibility, so as to not get lost in the interactive fiction.</description>
    </item>
    
    <item>
      <title>Pen Tutorial</title>
      <link>http://semiosis.github.io/posts/pen-tutorial/</link>
      <pubDate>Sun, 11 Jul 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/posts/pen-tutorial/</guid>
      <description>Quick Setup using Docker   A time-traveling wizard who uses a magic book and pen to create worlds.
The following commands set up pen.el for the first time.
 Apply for a GPT-3 key https://beta.openai.com/ Free AIx GPT-J-6B key https://apps.aixsolutionsgroup.com/ The AIx API is under heavy development. Multiple completions is currently being emulated by making several calls. Therefore, Pen.el will seem less responsive with GPT-J, currently.  These are the steps to run Pen on a linux machine.</description>
    </item>
    
    <item>
      <title>Pen.el (Prompt Engineering in Emacs)</title>
      <link>http://semiosis.github.io/pen/</link>
      <pubDate>Fri, 02 Jul 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/pen/</guid>
      <description>Introducing Pen.el The pen of imagination - |:ϝ∷¦ϝ.
  Pen.el integrates LMs (Language Models) such as OpenAI&amp;rsquo;s GPT-3 or EleutherAI&amp;rsquo;s GPT-J into emacs by generating functions from prompts that map emacs&amp;rsquo;s corners loosely onto LMs. These functions can be used interactively or non- interactively and in a variety of configurable ways. Pen.el also facilitates the creation, development, discovery and usage of prompts. It&amp;rsquo;s completely free, libre and open-source.
         Pen.</description>
    </item>
    
    <item>
      <title>Pen.el (Prompt Engineering in Emacs)</title>
      <link>http://semiosis.github.io/posts/pen/</link>
      <pubDate>Fri, 02 Jul 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/posts/pen/</guid>
      <description>Introducing Pen.el The pen of imagination - |:ϝ∷¦ϝ.
  Pen.el integrates LMs (Language Models) such as OpenAI&amp;rsquo;s GPT-3 or EleutherAI&amp;rsquo;s GPT-J into emacs by generating functions from prompts that map emacs&amp;rsquo;s corners loosely onto LMs. These functions can be used interactively or non- interactively and in a variety of configurable ways. Pen.el also facilitates the creation, development, discovery and usage of prompts. It&amp;rsquo;s completely free, libre and open-source.
         Pen.</description>
    </item>
    
    <item>
      <title>TomatoBear Story</title>
      <link>http://semiosis.github.io/philosophy/tomatobear-story/</link>
      <pubDate>Tue, 29 Jun 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/philosophy/tomatobear-story/</guid>
      <description>Perspective Stories will auto-complete one day By this, I mean, if I place an incomplete story on GitHub, this will autocomplete one day because an AGI will go looking for it, find it on GitHub and publish the completed version somewhere, but I can be working on it now, if I want.
Therefore, I must focus on connecting things to sources of immutable truth.
Journal &amp;lt;2021-06-29 Tue&amp;gt;  I have uploaded the story I will document the progress of its evolution here.</description>
    </item>
    
    <item>
      <title>The Semiosis of Angels</title>
      <link>http://semiosis.github.io/philosophy/the-semiosis-of-angels/</link>
      <pubDate>Mon, 28 Jun 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/philosophy/the-semiosis-of-angels/</guid>
      <description>Books in question:  The Semiosis of Angels by John Deely (2004) (PDF) Freedom by Daniel Suarez (PDF)    Thoughts  https://semiosis.github.io/posts/beyond-the-boundaries-of-paradigms/  |:ϝ∷¦ϝ This excerpt:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  Or, to put it perhaps more plainly, can semiosis extend even beyond the world of matter and motion, to achieve its effect and proper work also in a realm of pure spirits bodiless from the start?</description>
    </item>
    
    <item>
      <title>Representing multiverses with Datomic</title>
      <link>http://semiosis.github.io/posts/representing-multiverses-with-datomic/</link>
      <pubDate>Sat, 26 Jun 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/posts/representing-multiverses-with-datomic/</guid>
      <description>Related articles  Language models are multiverse generators :: Moire  |:ϝ∷¦ϝ&amp;rsquo;s blog post on exploring language models.   Datomic with Rich Hickey - YouTube Writing Datomic in Clojure - Rich Hickey - YouTube richhickey.md GitHub  Rich Hickey on becoming a better developer   Notes: https://github.com/semiosis/code-org-tidbits/blob/master/datomic/basic-query.    Project code https://github.com/semiosis/pen.el/  Summary After reading |:ϝ∷¦ϝ&amp;rsquo;s blog article LMs are multiverse generators :: Moire, I decided to take a closer look into Datomic as a possible store for LM generations.</description>
    </item>
    
    <item>
      <title>explainshell with GPT-3</title>
      <link>http://semiosis.github.io/posts/explainshell-with-gpt-3/</link>
      <pubDate>Wed, 16 Jun 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/posts/explainshell-with-gpt-3/</guid>
      <description>Summary I make a simple GPT-3 prompt to explain shell code while using emacs.
It mimics the functionality of explainshell but it&amp;rsquo;s able to also describe the purpose of commands with syntax and those that are semi-baked or pseudocode.
 Related https://mullikine.github.io/posts/crontab-guru-in-emacs/  Demo  --  Prompt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135  in-development: no title: &amp;#34;explain a shell command&amp;#34; issues: design-patterns: # future-titles: &amp;#34;&amp;#34; # aims: doc: &amp;#34;Explain what a shell command does&amp;#34; # aims: |+ # - More abstractive rewording prompt-version: 1 # &amp;lt;:pp&amp;gt; defines a point where the following # text is concatenated before the postprocessor # is run.</description>
    </item>
    
    <item>
      <title>nlsh (Natural Language Shell) with GPT-3</title>
      <link>http://semiosis.github.io/posts/nlsh-natural-language-shell/</link>
      <pubDate>Wed, 16 Jun 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/posts/nlsh-natural-language-shell/</guid>
      <description>Summary I extend my openai-complete script with REPL capabilities and use it to create parameterised nlsh REPLs for different Operating Systems.
I use comint, the emacs mode for managing REPLs and rlwrap to manage history and allow me to run the REPL without emacs.
I also generalise it within my prompt description format as &amp;ldquo;conversation mode&amp;rdquo; which enables me to have rolling conversations with a prompt.
So far, I have not implemented any kind of pseudo-memory system for rolling conversation.</description>
    </item>
    
    <item>
      <title>GPT-3 assistants for emacs modes</title>
      <link>http://semiosis.github.io/posts/gpt-3-assistants-for-emacs-modes/</link>
      <pubDate>Wed, 02 Jun 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/posts/gpt-3-assistants-for-emacs-modes/</guid>
      <description>Summary In this article I will show how I transition from using shell script to emacs lisp with my &amp;lsquo;any topic&amp;rsquo; tutor in emacs lisp.
I am working on integrating GPT-3, GPT-j and more GPT completion engines into emacs, and connecting more and more emacs packages to GPT-3.
1 2  # Latest docker image of =pen.el= docker run --rm -ti --entrypoint= semiosis/pen.el:latest ./run.sh   Here is an assistant for any major mode / context.</description>
    </item>
    
    <item>
      <title>Generate graphviz and prolog from org-brain</title>
      <link>http://semiosis.github.io/posts/generate-graphviz-and-prolog-from-org-brain/</link>
      <pubDate>Thu, 06 May 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/posts/generate-graphviz-and-prolog-from-org-brain/</guid>
      <description>Summary I would like to be creating graphs interactively with org-brain and then using them to generate graphviz, plantuml and mermaid diagrams, and also knowledge bases with prolog.
Why Prolog? Prolog is incredibly useful for querying KBs. If I plan on working for a large corporation with their own ontologies and knowledge graphs, then I will want to be skilled with Prolog.
Graphviz  --  A generated graphviz neato diagram This has been generated from an org-brain.</description>
    </item>
    
    <item>
      <title>Network exploration with nmap and emacs</title>
      <link>http://semiosis.github.io/posts/network-exploration-with-nmap-and-emacs/</link>
      <pubDate>Wed, 05 May 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/posts/network-exploration-with-nmap-and-emacs/</guid>
      <description>Summary I create some scripts based on nmap for network exploration. I then make user interfaces for their output based on tabulated-list-mode. I create some bindings to operate on the tabulated nmap output.
Demo  --  Scripts nmap wrapper 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  #!</description>
    </item>
    
    <item>
      <title>Subjects and Universal Grammar</title>
      <link>http://semiosis.github.io/philosophy/subjects-and-universal-grammar/</link>
      <pubDate>Mon, 03 May 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/philosophy/subjects-and-universal-grammar/</guid>
      <description>  </description>
    </item>
    
    <item>
      <title>Basics of Semiotics</title>
      <link>http://semiosis.github.io/philosophy/the-basics-of-semiotics/</link>
      <pubDate>Sat, 01 May 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/philosophy/the-basics-of-semiotics/</guid>
      <description>Books in question: Basics of Semiotics Advances in Semiotics by John N. Deely (PDF)     Chapters read:    Literary Semiotics And The Doctrine Of Signs    Semiotics: Method Or Point Of View?    Semiosis: The Subject Matter Of Semiotic Inquiry    Signs: The Medium Of Semiosis    Zoosemiotics And Anthroposemiotics      Glossary 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  semiosis It is important to understand what I mean by semiosis.</description>
    </item>
    
    <item>
      <title>Impossible Languages</title>
      <link>http://semiosis.github.io/philosophy/impossible-languages/</link>
      <pubDate>Sat, 01 May 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/philosophy/impossible-languages/</guid>
      <description>Books in question:  The Boundaries of Babel (The Brain and the Enigma of Impossible Languages) by Andrea Moro (2008) (PDF) Impossible Languages by Andrea Moro (2016) (PDF)    Glossary:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  universal grammar Arguments for: - Convergence neurobiological correlates https://mitpress.</description>
    </item>
    
    <item>
      <title>tmux-integrated GPT-3, stack-exchange and google code help</title>
      <link>http://semiosis.github.io/posts/tmux-integrated-gpt-3-stack-exchange-and-google-code-help/</link>
      <pubDate>Sat, 01 May 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/posts/tmux-integrated-gpt-3-stack-exchange-and-google-code-help/</guid>
      <description>Summary When I have a question about code, I don&amp;rsquo;t want to forget about the multiple avenues for looking for help.
I just make a convenience script to look for help.
Demo  --  Make scripts tcq
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  #!/bin/bash export TTY ( hs &amp;#34;$(basename &amp;#34;$0&amp;#34;)&amp;#34; &amp;#34;$@&amp;#34; &amp;#34;#&amp;#34; &amp;#34;&amp;lt;==&amp;#34; &amp;#34;$(ps -o comm= $PPID)&amp;#34; 0&amp;lt;/dev/null ) &amp;amp;&amp;gt;/dev/null lang=&amp;#34;$1&amp;#34; question=&amp;#34;$@&amp;#34; slug=&amp;#34;$(printf -- &amp;#34;%s\n&amp;#34; &amp;#34;$@&amp;#34; | tr &amp;#39;\n&amp;#39; &amp;#39; &amp;#39; | sed &amp;#39;s/ $//&amp;#39; | slugify | cut -c -20)&amp;#34; session_id=&amp;#34;$(tm ss -n zsh -s cq -c ~ | cut -d : -f 1)&amp;#34; pcq=&amp;#34;$(tm -d -te nw -P -n &amp;#34;cq-$slug&amp;#34; -d -t &amp;#34;$session_id&amp;#34; -args cq &amp;#34;$@&amp;#34;)&amp;#34; tm -d -te nw -n &amp;#34;egr-$slug&amp;#34; -d -t &amp;#34;$session_id&amp;#34; -args egr &amp;#34;$@&amp;#34; ( sleep 5 psx=&amp;#34;$(tm -d -te nw -P -n &amp;#34;sx-$slug&amp;#34; -d -t &amp;#34;$session_id&amp;#34; -args sx &amp;#34;$@&amp;#34;)&amp;#34; tmux select-window -t &amp;#34;$psx&amp;#34; ) &amp;amp; tmux select-window -t &amp;#34;$pcq&amp;#34; TMUX= tmux attach -t &amp;#34;$session_id&amp;#34;   cq</description>
    </item>
    
    <item>
      <title>Auto-suggest tooling to handle ports on a network</title>
      <link>http://semiosis.github.io/posts/auto-suggest-tooling-to-handle-ports-on-a-network/</link>
      <pubDate>Fri, 30 Apr 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/posts/auto-suggest-tooling-to-handle-ports-on-a-network/</guid>
      <description>Summary Given a server (default localhost), suggest tooling to handle said ports.
For example, if you are running a postgres server, suggest pgcli (a TUI) to allow you to connect to it.
Be more intelligent than this, though.
Tools to accommodate  https://github.com/dbcli/mycli https://github.com/dbcli/pgcli  Files too somehow?  https://github.com/dbcli/litecli  elisp Detect ports shell n-list-open-ports
1 2 3 4 5 6 7 8 9 10 11 12  #!/bin/bash export TTY ( hs &amp;#34;$(basename &amp;#34;$0&amp;#34;)&amp;#34; &amp;#34;$@&amp;#34; &amp;#34;#&amp;#34; &amp;#34;&amp;lt;==&amp;#34; &amp;#34;$(ps -o comm= $PPID)&amp;#34; 0&amp;lt;/dev/null ) &amp;amp;&amp;gt;/dev/null hn=&amp;#34;$1&amp;#34; : &amp;#34;${hn:=&amp;#34;localhost&amp;#34;}&amp;#34; { echo &amp;#34;Port State Service&amp;#34; sudo nmap -sT -O &amp;#34;$hn&amp;#34; | sed &amp;#34;0,/^PORT /{d}&amp;#34; | sed &amp;#34;/^[^0-9]\\+/,\$d&amp;#34; } | sed &amp;#34;s/ \\+/,/g&amp;#34; | pavs   ports-tablist This generates a CSV.</description>
    </item>
    
    <item>
      <title>Prolog and Natural-Language Analysis</title>
      <link>http://semiosis.github.io/philosophy/prolog-and-natural-language-analysis/</link>
      <pubDate>Fri, 30 Apr 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/philosophy/prolog-and-natural-language-analysis/</guid>
      <description>Book in question Prolog and Natural-Language Analysis by Fernando C. N. Pereira and Stuart M. Shieber (PDF) Notes on Semantic Nets and Frames http://www.eecs.qmul.ac.uk/~mmh/AINotes/AINotes4.pdf  Review This book has been interesting so far.
On reading the 1st chapter, I discovered how to build Semantic Networks in prolog.
On reading the 2nd chapter I realised I would like to make a NL parser in prolog. It would a fast way to explore building my own programmatic (as opposed to transformer-based) NL parser.</description>
    </item>
    
    <item>
      <title>Zero-shot NLP in Clojure</title>
      <link>http://semiosis.github.io/posts/zero-shot-nlp-in-clojure/</link>
      <pubDate>Fri, 30 Apr 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/posts/zero-shot-nlp-in-clojure/</guid>
      <description>Original article http://gigasquidsoftware.com/blog/2021/03/15/breakfast-with-zero-shot-nlp/ Code http://github.com/mullikine/zero-shot-nlp   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  (ns zero-shot-nlp.core (:gen-class) (:require [libpython-clj2.require :refer [require-python]] [libpython-clj2.python :as py :refer [py. py.. py.-]])) (require-python &amp;#39;[transformers :bind-ns]) (require &amp;#39;[clojure.pprint :as p]) (use &amp;#39;[clojure.java.shell :only [sh]]) ;; (in-ns &amp;#39;clojure.pprint) (defn -main &amp;#34;I classify stuff.&amp;#34; [&amp;amp; args] ;; import transformers; transformers.</description>
    </item>
    
    <item>
      <title>Universal file parser and query tool in emacs</title>
      <link>http://semiosis.github.io/posts/universal-file-parser-in-emacs/</link>
      <pubDate>Thu, 29 Apr 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/posts/universal-file-parser-in-emacs/</guid>
      <description>Summary I make a way to get a more abstract representation of any type of file or buffer in emacs utilising parsers, antlr4 in particular.
I also want to be able to query the contents of the source code.
I also want to be able to query prose programmatically.
Motivation In the past I have used ctags to get simple lists of source code components such as functions and classes. I would like to have much finer control over queries to source code.</description>
    </item>
    
    <item>
      <title>Building a Clojure environment in emacs</title>
      <link>http://semiosis.github.io/posts/building-a-clojure-environment-in-emacs/</link>
      <pubDate>Wed, 28 Apr 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/posts/building-a-clojure-environment-in-emacs/</guid>
      <description>Summary  I install/learn some existing tooling I create some tools for missing functionality  Missing functionality  Google (semantic) search for clojure libaries / versions  clj-refactor.el lists all libraries on clojars, but you have to lexically select from that &amp;ldquo;web framework&amp;rdquo; should yield lists of web framework libraries   Require a library into a source file from the dependencies imported in project.clj  Install tools  https://github.com/clojure-emacs/clj-refactor.el  clj-refactor.</description>
    </item>
    
    <item>
      <title>Creating a clojure app with terraform and AWS Cloud</title>
      <link>http://semiosis.github.io/posts/creating-a-clojure-app-with-terraform-and-aws-cloud/</link>
      <pubDate>Tue, 27 Apr 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/posts/creating-a-clojure-app-with-terraform-and-aws-cloud/</guid>
      <description>Summary These are the steps I have taken to automate the process of building a Web Application in Clojure and deploying said application to an AWS cluster defined by a Terraform module.
This is a work in progress.
Original article https://dzone.com/articles/deploy-a-clojure-web-application-to-aws-using-terr
I have taken steps and copied code from this article.
Design I have chosen Clojure as the language to implement the blob uploader for the following reasons:
 It is very reliable It is easy to understand REPL workflow  Live updates   One language for both the back-end and front-end It&amp;rsquo;s the language I&amp;rsquo;m growing into for most of my work It has very good support for concurrency Access to all of Java&amp;rsquo;s libraries Access to all of Python&amp;rsquo;s libraries via clj-python/libpython-clj  I was initially working with Terraform 0.</description>
    </item>
    
    <item>
      <title>Exploring Neuralink concepts with GPT-3 (WIP)</title>
      <link>http://semiosis.github.io/posts/exploring-neuralink-concepts-with-gpt-3/</link>
      <pubDate>Wed, 14 Apr 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/posts/exploring-neuralink-concepts-with-gpt-3/</guid>
      <description>This article is a work in progress.
Summary I create several org-brain repositories for exploratory learning and ideation.
1 2 3 4 5 6 7 8 9 10 11 12  billboard exploratory fungible ideation infogetics infrastructure-tooling neuralink open-source-alternatives reference thoughts tooling welfare-organisations   I then use GPT-3 to discuss topics and why they are important.
Mind terminal   Glossaries  http://github.com/mullikine/glossaries-gh/blob/master/biochemistry.txt http://github.com/mullikine/glossaries-gh/blob/master/brain-computer-interface-bci.txt http://github.com/mullikine/glossaries-gh/blob/master/neuralink.txt http://github.com/mullikine/glossaries-gh/blob/master/neuroscience.txt http://github.com/mullikine/glossaries-gh/blob/master/neural-engineering.txt http://github.com/mullikine/glossaries-gh/blob/master/gpt.txt http://github.com/mullikine/glossaries-gh/blob/master/ai-safety.txt http://github.</description>
    </item>
    
    <item>
      <title>GPT-3 is The Thing</title>
      <link>http://semiosis.github.io/posts/gpt-3-like-the-thing/</link>
      <pubDate>Wed, 14 Apr 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/posts/gpt-3-like-the-thing/</guid>
      <description>Summary The Thing is a lot like GPT-3 due to it being extremely capable, but limited to the queries you give it.
It&amp;rsquo;s as powerful as your understanding on how to talk to it.
The Thing is a black box computer in the nomes series by Terry Pratchett.
I make reference to the first book in the series Truckers.
This book is freely available on the Internet Archive.
 Truckers by Terry Pratchett https://archive.</description>
    </item>
    
    <item>
      <title>Imaginary programming with GPT-3</title>
      <link>http://semiosis.github.io/posts/imaginary-programming-with-gpt-3/</link>
      <pubDate>Thu, 08 Apr 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/posts/imaginary-programming-with-gpt-3/</guid>
      <description>Code https://github.com/semiosis/pen.el Prompts https://github.com/semiosis/prompts/ Disclaimer Please contribute as this is an open source project! It&amp;rsquo;s very hard to find free prompts online currently and that&amp;rsquo;s because everyone is out for themselves. Please support open source. Thank you. Glossary http://github.com/semiosis/glossaries-gh/blob/master/imaginary-programming.txt Thesis https://github.com/semiosis/imaginary-programming-thesis/blob/master/thesis.org  Summary This is a demonstration of an imaginary programming environment. There may be nothing else like it in the world today.
The world needs to get ready for the next generations of Large LMs, such as GPT-4.</description>
    </item>
    
    <item>
      <title>Fictional statements of remorse with GPT-3 in the 1st and 3rd person</title>
      <link>http://semiosis.github.io/posts/fictional-statements-of-remorse-with-gpt-3/</link>
      <pubDate>Wed, 07 Apr 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/posts/fictional-statements-of-remorse-with-gpt-3/</guid>
      <description>Summary I use GPT-3 to generate fictional statements of remorse.
It should be noted that this is only one such way that GPT-3 will upheave legal process.
RemorseBot (in the 1st person)  --  RemorseBot (in the 3rd person)  --  Prompts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108  title: &amp;#34;Statement of remorse&amp;#34; # future-titles: &amp;#34;&amp;#34; # aims: |+ # - More abstractive rewording doc: &amp;#34;&amp;#34; # aims: |+ # - More abstractive rewording prompt-version: 1 # &amp;lt;:pp&amp;gt; defines a point where the following # text is concatenated before the postprocessor # is run.</description>
    </item>
    
    <item>
      <title>Translating with GPT-3 and Emacs</title>
      <link>http://semiosis.github.io/posts/translating-with-gpt-3-and-emacs/</link>
      <pubDate>Tue, 06 Apr 2021 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/posts/translating-with-gpt-3-and-emacs/</guid>
      <description>Summary Sorry for the lazy blog post today. I just ask GPT3 for some subtopics of ancient roman law as I am looking for a cool word to use. I would like to know what these words mean, so I use GPT3 for that too.
Subtopics of Ancient Roman Law These were generated by GPT-3.
1 2 3 4 5  aedilitas advocatus auctoritas augur auspex caupona cena clientela contio domus ius ludos ministra mos ora otium praetor quaestio res mancipi sacerdos status suovetaurilia tabella tribunus plebis via vir    --  GPT-3 Language detection and translation  language Latin  English translation:</description>
    </item>
    
    <item>
      <title>GPT-3 mind maps with an AI tutor for any topic</title>
      <link>http://semiosis.github.io/posts/gpt-3-for-building-mind-maps-with-an-ai-tutor-for-any-topic/</link>
      <pubDate>Mon, 29 Mar 2021 00:00:00 +1300</pubDate>
      
      <guid>http://semiosis.github.io/posts/gpt-3-for-building-mind-maps-with-an-ai-tutor-for-any-topic/</guid>
      <description>Code http://github.com/semiosis/pen.el Prompts http://github.com/semiosis/prompts  Summary I combine GPT-3 with org-brain to expand on topics, suggesting subtopics and providing an interactive tutor for any topic.
Demonstration Subtopic generation I demonstrate how to explore arbitrary topics with GPT-3 by automatically generating subtopics, and then allowing you to invoke the GPT-3 tutor to answer questions within that context.
 --  Tutor demonstration  Rolling conversation is a work in progress, but on its way.</description>
    </item>
    
    <item>
      <title>Generating pickup lines with GPT-3</title>
      <link>http://semiosis.github.io/posts/generating-pickup-lines-with-gpt-3/</link>
      <pubDate>Sat, 27 Mar 2021 00:00:00 +1300</pubDate>
      
      <guid>http://semiosis.github.io/posts/generating-pickup-lines-with-gpt-3/</guid>
      <description>Latest version of the pick up lines prompt http://github.com/mullikine/prompts/blob/master/prompts/very-witty-pick-up-lines-for-a-topic.prompt Original Pick-up-lines prompt by Jan Kolar https://www.producthunt.com/posts/500-openers-for-tinder-written-by-gpt-3 \
https://www.reddit.com/r/GPT3/comments/mdl7fl/500%5Fopeners%5Ffor%5Ftinder%5Fwritten%5Fby%5Fgpt3%5Fthe%5Fprompt/ Pen tutorial https://mullikine.github.io/posts/pen-tutorial/  Summary I create a prompt in my prompt description format and use it to generate some pickup lines.
Demonstration (v2 with emacs counsel integration) New results are fed into a fuzzy finder as they are generated. I can stop and select at any time.
 --  Demonstration (version 2)  --  Pick up lines with the topic &amp;ldquo;SETTLERS OF CATAN&amp;rdquo; ⌂ ⌂⌂ ━ ━ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  When playing Settlers of Catan, the shortest route is a straight line to my heart.</description>
    </item>
    
    <item>
      <title>About</title>
      <link>http://semiosis.github.io/about/</link>
      <pubDate>Wed, 17 Mar 2021 00:00:00 +1300</pubDate>
      
      <guid>http://semiosis.github.io/about/</guid>
      <description>Semiosis is a GitHub organisation focused on building programming languages to keep computing textual.
It is also a blog on Natural Language Processing and Formal Language Theory.
Noam Chomsky - &amp;ldquo;The machine, the ghost, and the limits of understanding&amp;rdquo; - YouTube
Shane Mulligan  Website: Bodacious Blog GitHub: https://github.com/mullikine/ CV: https://mullikine.github.io/cv/  TakaheAI  Website http://takaheai.github.io/  </description>
    </item>
    
    <item>
      <title>Examplary (a example-oriented programming language)</title>
      <link>http://semiosis.github.io/examplary/</link>
      <pubDate>Wed, 17 Mar 2021 00:00:00 +1300</pubDate>
      
      <guid>http://semiosis.github.io/examplary/</guid>
      <description>Examplary is an example-oriented DSL that can be used to construct and compose functions based on prompts and external String-&amp;gt;String commands.
 Emacs Lisp: http://github.com/semiosis/pen.el/blob/master/src/pen-examplary.el Clojure: http://github.com/semiosis/examplary  Using examplary, one can keep track of their various String-&amp;gt;String functions but also:
 generate prompts from an example generator design prompts using design patterns   1 2 3 4 5 6 7 8 9 10 11  fifth-generation programming language 5GL Any programming language based on problem solving using constraints given to the program, rather than using an algorithm written by a programmer.</description>
    </item>
    
    <item>
      <title>Autocompleting anything with GPT-3 in emacs</title>
      <link>http://semiosis.github.io/posts/autocompleting-anything-with-gpt-3-in-emacs/</link>
      <pubDate>Tue, 16 Mar 2021 00:00:00 +1300</pubDate>
      
      <guid>http://semiosis.github.io/posts/autocompleting-anything-with-gpt-3-in-emacs/</guid>
      <description>Emacs package https://github.com/semiosis/pen.el Help/developers desperately needed in developing pen.el! Prompt engineering is very easy so don&amp;rsquo;t be intimidated! Prompt http://github.com/semiosis/prompts/blob/master/prompts/generic-completion-50-tokens.prompt  Summary I make a prompt for the OpenAI API which completes given a file type and some preceding text.
I then make a company-mode completion function for it, and then demo its usage.
This gives me a generic completion mechanism when dealing with any type of document.
Demonstration This is GPT-3 completing some text for me.</description>
    </item>
    
    <item>
      <title>A tour of Ryan Ong&#39;s - NLP 365</title>
      <link>http://semiosis.github.io/posts/ryan-ong-nlp-365/</link>
      <pubDate>Sat, 13 Mar 2021 00:00:00 +1300</pubDate>
      
      <guid>http://semiosis.github.io/posts/ryan-ong-nlp-365/</guid>
      <description>Glossaries nlp-natural-language-processing.txt information-retrieval.txt fasttext.txt transformer.txt nmt-neural-machine-translation.txt information-theory.txt  Summary I go over Ryan Ong&amp;rsquo;s series on NLP, adding terms to my glossaries and reproducing what he&amp;rsquo;s done.
 Finished reading &amp;lt;2021-03-13 Sat&amp;gt;
 Day 1: What is Natural Language Processing - Ryan Ong Day 2: Damerau-Levenshtein Distance - Ryan Ong Day 3: Word Embeddings - Ryan Ong  Terms in the green text have added to my glossary.
  This is the project that introduced me to GloVe a few years ago.</description>
    </item>
    
    <item>
      <title>Look for my friend&#39;s wagon using OpenAI CLIP</title>
      <link>http://semiosis.github.io/posts/look-for-my-friend-s-wagon-using-openai-clip/</link>
      <pubDate>Fri, 12 Mar 2021 00:00:00 +1300</pubDate>
      
      <guid>http://semiosis.github.io/posts/look-for-my-friend-s-wagon-using-openai-clip/</guid>
      <description>Full demonstration I show you how easy it is to search for an arbitrary thing inside of an arbitrary youtube video.
I am blogging and recording as I am demonstrating the technology.
Skip to 3 minutes to see the magic.

Summary I am looking for my friend&amp;rsquo;s wagon in a youtube video.
 This is the video Here&amp;rsquo;s What We REALLY Think Of Your Cars 5 - YouTube  The images of various wagons should appear after I run the command which I have bound in emacs.</description>
    </item>
    
    <item>
      <title>Reading about DALL-E</title>
      <link>http://semiosis.github.io/posts/reading-about-dall-e/</link>
      <pubDate>Fri, 12 Mar 2021 00:00:00 +1300</pubDate>
      
      <guid>http://semiosis.github.io/posts/reading-about-dall-e/</guid>
      <description>Article https://openai.com/blog/dall-e/ Original paper https://arxiv.org/abs/2102.12092.pdf  Authors of Paper - Aditya Ramesh - Mikhail Pavlov - Gabriel Goh - Scott Gray - Chelsea Voss - Alec Radford - Mark Chen - Ilya Sutskever
Summary of DALL-E from Arxiv 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  Text-to-image generation has traditionally focused on finding better modeling assumptions for training on a fixed dataset.</description>
    </item>
    
    <item>
      <title>Context menus based on GPT-3</title>
      <link>http://semiosis.github.io/posts/context-menus-based-on-gpt-3/</link>
      <pubDate>Tue, 09 Mar 2021 00:00:00 +1300</pubDate>
      
      <guid>http://semiosis.github.io/posts/context-menus-based-on-gpt-3/</guid>
      <description>Summary I create a GPT-3 prompt for testing to see if code is Haskell and use it as a test inside emacs to suggest further functions.
 Prompt file http://github.com/semiosis/prompts/blob/master/prompts/get-language.prompt  Demonstration As you can see, GPT-3 is able to detect the language and I can use that as a test in my emacs to provide further functions. The suggested function was yet another GPT-3 prompt function for translating Haskell into Clojure.</description>
    </item>
    
    <item>
      <title>Google ngrams in emacs</title>
      <link>http://semiosis.github.io/posts/google-ngrams-in-emacs/</link>
      <pubDate>Tue, 09 Mar 2021 00:00:00 +1300</pubDate>
      
      <guid>http://semiosis.github.io/posts/google-ngrams-in-emacs/</guid>
      <description>Summary I integrate the Google ngram viewer functionality into emacs for suggesting words in context.
Demonstration I demonstrate selecting alternative middle word for the given context words.

Code custom.el configuration
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  (defcustom google-ngrams-corpus &amp;#34;&amp;#34; &amp;#34;Google ngrams corpus&amp;#34; :type &amp;#39;string :group &amp;#39;system-custom :initialize #&amp;#39;custom-initialize-default :options (list &amp;#34;15 # english 2012&amp;#34; &amp;#34;16 # english fiction&amp;#34; &amp;#34;26 # english 2019&amp;#34;) :set (lambda (_sym value) (myrc-set (tr &amp;#34;-&amp;#34; &amp;#34;_&amp;#34; (sym2str _sym)) value) (set _sym (sor value))) ;; The default :initialize is custom-initialize-reset ;; And uses the :set function ;; :initialize (lambda :get (lambda (_sym) (let* ((yaml (yamlmod-read-file &amp;#34;/home/shane/notes/myrc.</description>
    </item>
    
    <item>
      <title>spaCy in emacs</title>
      <link>http://semiosis.github.io/posts/spacy-in-emacs/</link>
      <pubDate>Tue, 09 Mar 2021 00:00:00 +1300</pubDate>
      
      <guid>http://semiosis.github.io/posts/spacy-in-emacs/</guid>
      <description>Summary I begin construction of an environment for developing with spaCy.
 Goals  spaCy pipeline builder/wizard Select and analyse text with spaCy linguistic features spaCy python playground text selection configuration of spaCy using emacs custom.el    deplacy demo  deplacy code https://github.com/KoichiYasuoka/deplacy  
Code generation and bindings 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  (defmacro etv-filter (cmd) (let* ((slug (slugify cmd)) (sym (str2sym (concat &amp;#34;etv-&amp;#34; slug)))) `(defun ,sym (&amp;amp;optional input) (interactive (list (my/selected-text))) (if (not input) (setq input (my/selected-text))) (etv (snc ,cmd input))))) (cl-loop for s in &amp;#39;(&amp;#34;partsofspeech&amp;#34; &amp;#34;entities&amp;#34; &amp;#34;displacy&amp;#34; &amp;#34;token-pos-dep&amp;#34; &amp;#34;sentiment&amp;#34; &amp;#34;segment-sentences&amp;#34;) do (eval (expand-macro `(etv-filter ,s)))) (define-key selected-keymap (kbd &amp;#34;Z n&amp;#34;) &amp;#39;ngram-query-replace) (define-key selected-keymap (kbd &amp;#34;Z S&amp;#34;) &amp;#39;sps-play-spacy) (define-key selected-keymap (kbd &amp;#34;Z P&amp;#34;) &amp;#39;etv-partsofspeech) (define-key selected-keymap (kbd &amp;#34;Z E&amp;#34;) &amp;#39;etv-entities) (define-key selected-keymap (kbd &amp;#34;Z D&amp;#34;) &amp;#39;etv-displacy) (define-key selected-keymap (kbd &amp;#34;Z T&amp;#34;) &amp;#39;etv-token-pos-dep) (define-key selected-keymap (kbd &amp;#34;Z N&amp;#34;) &amp;#39;etv-sentiment) (define-key selected-keymap (kbd &amp;#34;Z G&amp;#34;) &amp;#39;etv-segment-sentences)     Configuration yaml I store the configuration of spaCy inside a yaml file.</description>
    </item>
    
    <item>
      <title>An operating system based on GPT-3</title>
      <link>http://semiosis.github.io/posts/an-operating-system-based-on-gpt-3/</link>
      <pubDate>Mon, 08 Mar 2021 00:00:00 +1300</pubDate>
      
      <guid>http://semiosis.github.io/posts/an-operating-system-based-on-gpt-3/</guid>
      <description>Reference http://github.com/semiosis/examplary  Summary I assume that GPT-3 or some descendant of it will become the primary interface to the computer.
I create a configuration option to enable / disable GPT-3.
When disabled, the environment will resort to alternative means of performing tasks.
Configuration 1  vim +/&amp;#34;use_gpt3: on&amp;#34; &amp;#34;$NOTES/myrc.yaml&amp;#34;     1  vim +/&amp;#34;summarize) {&amp;#34; &amp;#34;$SCRIPTS/s&amp;#34;   If gpt3 is enabled, filter through OpenAI API abstractive summarizer Otherwise, use sumy.</description>
    </item>
    
    <item>
      <title>A natural language database using a single GPT prompt</title>
      <link>http://semiosis.github.io/posts/a-natural-language-database-using-a-single-gpt-prompt/</link>
      <pubDate>Sun, 07 Mar 2021 00:00:00 +1300</pubDate>
      
      <guid>http://semiosis.github.io/posts/a-natural-language-database-using-a-single-gpt-prompt/</guid>
      <description>Original article https://www.gwern.net/GPT-3#the-database-prompt  Summary A single prompt describes transactions to and from a database.
GPT-3 is able to answer questions about the transactions that have taken place.
GPT-3 isn&amp;rsquo;t actually a database.
The LM simply understands language so well that describing the transactions that have taken place would naturally lead to the GPT-3 response.
The prompt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55  title: &amp;#34;database example&amp;#34; doc: &amp;#34;GPT-3 as a NL interface for semantically querying logic in prose&amp;#34; prompt: |+The database begins knowing nothing.</description>
    </item>
    
    <item>
      <title>Translating Haskell to Clojure with GPT-3</title>
      <link>http://semiosis.github.io/posts/translating-haskell-to-clojure-with-gpt-3/</link>
      <pubDate>Sun, 07 Mar 2021 00:00:00 +1300</pubDate>
      
      <guid>http://semiosis.github.io/posts/translating-haskell-to-clojure-with-gpt-3/</guid>
      <description>Relevant material https://hyperpolyglot.org/ml  Summary Who needs hyperpolyglot when you have GPT-3?
I translate Haskell into Clojure using the following prompt.
haskell-to-clojure.prompt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  title: &amp;#34;Translate Haskell to Clojure&amp;#34; prompt: |+Haskell: zip (map show [1,5,9]) [&amp;#34;a&amp;#34;,&amp;#34;b&amp;#34;,&amp;#34;c&amp;#34;] Clojure: (println (map vector &amp;#39;(1 2 3) &amp;#39;(4 5 6))) Haskell: map toUpper &amp;#34;MiXeD cAsE&amp;#34; Clojure: (clojure.</description>
    </item>
    
    <item>
      <title>crontab.guru in emacs and making a prompt with GPT-3 to copy it</title>
      <link>http://semiosis.github.io/posts/crontab-guru-in-emacs/</link>
      <pubDate>Sat, 06 Mar 2021 00:00:00 +1300</pubDate>
      
      <guid>http://semiosis.github.io/posts/crontab-guru-in-emacs/</guid>
      <description>Related https://crontab.guru/ Author http://github.com/mullikine  Summary I build some functionality into emacs to use crontab.guru behind the scenes to interpret tab lines displaying inside of emacs, without using the web browser.
I then build a GPT-3 prompt which does exactly the same thing without crontab.guru and provide the initial script I made to examplary (my GPT-3 DSL) as an example generator, to enhance the prompt if that is needed later.</description>
    </item>
    
    <item>
      <title>Creating a playground for GPT-3 in emacs</title>
      <link>http://semiosis.github.io/posts/creating-a-playground-for-gpt-3-in-emacs/</link>
      <pubDate>Thu, 18 Feb 2021 00:00:00 +1300</pubDate>
      
      <guid>http://semiosis.github.io/posts/creating-a-playground-for-gpt-3-in-emacs/</guid>
      <description>This is outdated.
 Code https://github.com/semiosis/pen.el Prompts https://github.com/semiosis/prompts meetup.com event https://www.meetup.com/Code-Craft-Dunedin/events/276407816/ Slides http://github.com/mullikine/presentation-prompt-engineering-in-emacs/blob/master/presentation.pdf     Latest docs (12.08.21)      GitHub project https://github.com/semiosis/pen.el/   Project timeline and objectives https://github.com/semiosis/pen.el/tree/master/docs   Prompts README http://github.com/semiosis/prompts/blob/master/README.org   ★ Tutorial https://semiosis.github.io/posts/pen-tutorial/   Video demo of Pen.el Augment Minds 2021: Demo of Loom and Pen.el - YouTube   Bash prompting README http://github.com/semiosis/pen.el/blob/master/docs/using-prompt-functions-in-bash.org    Demonstration (2021-02-18)  --  Prompt-Engineering Part 1: Building an environment Summary of talk I received a key for the OpenAI API 2 weeks ago, just a couple of days before my birthday.</description>
    </item>
    
    <item>
      <title>OpenAI API for NLP</title>
      <link>http://semiosis.github.io/posts/openai-api-for-nlp/</link>
      <pubDate>Fri, 12 Jun 2020 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/posts/openai-api-for-nlp/</guid>
      <description>OpenAI API https://beta.openai.com/  Summary I&amp;rsquo;d like to add some OpenAI support to emacs. GPT-3 is easy to integrate because it is a very general-purpose transformer. In a later article, I&amp;rsquo;d like to integrate more specialised huggingface transformers.
Results Here are some of the things I had managed to do with emacs and GPT-3 so far.
 Imaginary programming with GPT-3 // Bodacious Blog  Here I assemble an imaginary programming environment in GPT-3.</description>
    </item>
    
    <item>
      <title>Review of &#39;[2006.03511] Unsupervised Translation of Programming Languages&#39;</title>
      <link>http://semiosis.github.io/philosophy/review-of-2006-03511-unsupervised-translation-of-programming-languages/</link>
      <pubDate>Wed, 10 Jun 2020 00:00:00 +1200</pubDate>
      
      <guid>http://semiosis.github.io/philosophy/review-of-2006-03511-unsupervised-translation-of-programming-languages/</guid>
      <description>Original article 2006.03511 Unsupervised Translation of Programming Languages News https://venturebeat.com/2020/06/08/facebooks-transcoder-ai-converts-code-from-one-programming-language-into-another/ Research Lample et al. Researcher Guillaume Lample Facebook AI Research glample@fb.com  Fully unsupervised neural transcompiler  Converts languages obtained from GitHub  BigQuery   unsupervised  it looks for previously undetected patterns in data sets without labels and with a minimal amount of human supervision   outperforms rule-based baselines by a “significant” margin.  Model of TransCoder   seq2seq with attention</description>
    </item>
    
    <item>
      <title>Hydra - CI and release management for NixOS</title>
      <link>http://semiosis.github.io/posts/nix-hydra-ci/</link>
      <pubDate>Thu, 09 Jan 2020 00:00:00 +1300</pubDate>
      
      <guid>http://semiosis.github.io/posts/nix-hydra-ci/</guid>
      <description>Original article https://nixos.org/hydra/manual/   1 2 3 4  big bang integration The phenomenon where components are only tested together near the end of the development process.   Background Continuous Integration An automated system continuously or periodically:
 check out the source code of a project, build it, run tests, and produce reports for the developers.  CI Tools enable Lenthy tests Many projects have very large test sets (e.</description>
    </item>
    
    <item>
      <title>Setting up LSP with emacs (Go, Java, Python, Rust, C&#43;&#43;, Haskell, JS, TS, Ruby…)</title>
      <link>http://semiosis.github.io/posts/setting-up-lsp-with-emacs-attempt-2/</link>
      <pubDate>Thu, 05 Dec 2019 00:00:00 +1300</pubDate>
      
      <guid>http://semiosis.github.io/posts/setting-up-lsp-with-emacs-attempt-2/</guid>
      <description>Guides used https://www.mortens.dev/blog/emacs-and-the-language-server-protocol/ https://github.com/emacs-lsp/lsp-java   1 2 3 4 5  Debug Adaptor Protocol DAP The LSP of debugging. https://code.visualstudio.com/blogs/2018/08/07/debug-adapter-protocol-website    State of languages with LSP in my own environment  Also, I&amp;rsquo;m using GPT-3 for:  code generation comment generation       Language LSP Working Fallback working Current user experience TabNine enabled REPL / Playground DAP (debug) Working Static analysis Complaints Custom LSP improvements     Go ✓ ✓ Amazing ✓ ✓  ✓ Go toolchain changes too quickly    Python ✓ ✓ Amazing ✓ ✓ ✓ ✓     Racket ✓ ✓ racket-mode Amazing  ✓  ✓     Java ✓ ✓ eclim Good ✓ ✓ (default) ✓ ✓ A little slow.</description>
    </item>
    
  </channel>
</rss>
